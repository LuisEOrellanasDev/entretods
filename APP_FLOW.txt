===============================================================================
                        ENTRETODS - FLUJO COMPLETO DE LA APLICACI√ìN
===============================================================================

DESCRIPCI√ìN GENERAL
-------------------
Entretods es una aplicaci√≥n web colaborativa para gestionar gastos de viaje entre 
amigos. Utiliza Next.js 14, Firebase Authentication, PostgreSQL con Prisma, y 
un sistema de liquidaci√≥n inteligente para calcular deudas y sugerir pagos √≥ptimos.

TECNOLOG√çAS CLAVE
-----------------
- NUESTRAS: Server Actions, Middleware personalizado, Algoritmo de liquidaci√≥n, 
  Gesti√≥n de cookies, Validaciones de acceso, Rate limiting
- EXTERNAS: Firebase Auth, Firebase Admin SDK, Prisma ORM, PostgreSQL, Next.js

===============================================================================
                                FLUJO DEL USUARIO
===============================================================================

1. P√ÅGINA DE BIENVENIDA (/)
===========================

Archivo: src/app/page.tsx

QU√â MUESTRA:
- Header con logo "entretods"
- Botones "Iniciar Sesi√≥n" y "Registrarse"
- Mensaje: "Organiza gastos con tus amigos de manera simple"
- Iconos: ‚úàÔ∏è Crea viajes, üí∞ Registra gastos, ‚öñÔ∏è Liquida balances

L√ìGICA DEL MIDDLEWARE:
- Si el usuario YA tiene cookie de sesi√≥n ‚Üí redirige autom√°ticamente a /dashboard
- Si NO tiene sesi√≥n ‚Üí muestra la landing page
- C√≥digo en src/middleware.ts l√≠neas 56-61

RATE LIMITING:
- Aplicado a rutas de autenticaci√≥n: 10 intentos por minuto por IP
- Aplicado a server actions: 30 intentos por minuto por IP

---

2. REGISTRO DE USUARIO (/register)
==================================

Archivo: src/app/register/page.tsx

CAMPOS DEL FORMULARIO:
- Nombre (firstName)
- Apellido (lastName)
- Email
- Contrase√±a

FLUJO PASO A PASO:
1. Usuario llena formulario y hace submit ‚Üí handleSubmit() l√≠nea 23
2. FIREBASE AUTH (EXTERNA): createUserWithEmailAndPassword(auth, email, password)
3. FIREBASE AUTH (EXTERNA): updateProfile(user, displayName)
4. FIREBASE AUTH (EXTERNA): user.getIdToken() - obtiene token JWT
5. SERVER ACTION (NUESTRA): registerWithFirebaseAction(idToken, firstName, lastName)

DENTRO DEL SERVER ACTION (src/app/register/_actions/register.ts):
- FIREBASE ADMIN (EXTERNA): adminAuth.verifyIdToken(idToken) - verifica el token
- PRISMA (EXTERNA): prisma.user.upsert() - sincroniza usuario en PostgreSQL
- NUESTRA: createSessionCookieFromIdToken(idToken) - crea cookie de sesi√≥n

6. REDIRECCI√ìN: router.replace('/dashboard')

MANEJO DE ERRORES:
- Errores de Firebase se muestran en pantalla
- Validaciones de campos requeridos
- Estado de loading durante el proceso

---

3. INICIO DE SESI√ìN (/login)
============================

Archivo: src/app/login/page.tsx

CAMPOS DEL FORMULARIO:
- Email
- Contrase√±a

FLUJO PASO A PASO:
1. Usuario env√≠a credenciales ‚Üí handleSubmit() l√≠nea 17
2. FIREBASE AUTH (EXTERNA): signInWithEmailAndPassword(auth, email, password)
3. FIREBASE AUTH (EXTERNA): user.getIdToken() - token fresco
4. SERVER ACTION (NUESTRA): createSessionAction(idToken)

DENTRO DEL SERVER ACTION (src/app/login/_actions/createSesion.ts):
- FIREBASE ADMIN (EXTERNA): adminAuth.verifyIdToken(idToken)
- PRISMA (EXTERNA): prisma.user.upsert() - actualiza/crea usuario en DB
- NUESTRA: createSessionCookieFromIdToken(idToken)

5. REDIRECCI√ìN: router.replace('/dashboard')

DIFERENCIA CON REGISTRO:
- No actualiza displayName en Firebase
- Puede crear usuario en DB si no existe (upsert)

---

4. MIDDLEWARE DE PROTECCI√ìN
===========================

Archivo: src/middleware.ts

RUTAS PROTEGIDAS:
- /dashboard
- /travel/*
- /create-travel

L√ìGICA DE PROTECCI√ìN:
```
if (isProtectedRoute) {
  const token = request.cookies.get(COOKIE_NAME)?.value;
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
}
```

HEADERS DE SEGURIDAD APLICADOS:
- X-Frame-Options: DENY
- X-Content-Type-Options: nosniff
- Content-Security-Policy con nonce din√°mico
- Referrer-Policy: strict-origin-when-cross-origin

REDIRECTS LEGACY:
- /auth/login ‚Üí /login
- /auth/register ‚Üí /register

---

5. FUNCI√ìN DE AUTENTICACI√ìN CENTRAL
===================================

Archivo: src/lib/auth.ts

FUNCI√ìN auth() (NUESTRA):
```
export async function auth() {
  const decoded = await verifySessionCookie(); // Verifica cookie de sesi√≥n
  if (!decoded?.uid) return null;
  
  const user = await prisma.user.findFirst({
    where: {
      OR: [
        { firebaseUid: decoded.uid },
        decoded.email ? { email: decoded.email } : undefined,
      ]
    }
  });
  
  return { user: { ...user, name: `${firstName} ${lastName}`.trim() } };
}
```

PROCESO:
1. Verifica cookie de sesi√≥n con Firebase Admin
2. Busca usuario en PostgreSQL por firebaseUid o email
3. Retorna objeto de sesi√≥n con datos del usuario
4. Si algo falla, retorna null

---

6. GESTI√ìN DE COOKIES DE SESI√ìN
===============================

Archivo: src/lib/firebase/firebaseSesion.ts

CREAR COOKIE (NUESTRA):
```
export async function createSessionCookieFromIdToken(idToken: string) {
  // FIREBASE ADMIN: Crear cookie de sesi√≥n
  const sessionCookie = await adminAuth.createSessionCookie(idToken, { expiresIn });
  
  // NUESTRA: Configurar cookie en el navegador
  cookieStore.set(COOKIE_NAME, sessionCookie, {
    httpOnly: true,                    // No accesible desde JavaScript
    secure: NODE_ENV === 'production', // HTTPS en producci√≥n
    sameSite: 'lax',                   // Protecci√≥n CSRF
    maxAge: Math.floor(expiresIn / 1000),
    path: '/',
  });
}
```

VERIFICAR COOKIE (NUESTRA):
```
export async function verifySessionCookie() {
  const sessionCookie = cookieStore.get(COOKIE_NAME)?.value;
  if (!sessionCookie) return null;
  
  // FIREBASE ADMIN: Verificar validez de la cookie
  const decoded = await adminAuth.verifySessionCookie(sessionCookie, true);
  return decoded;
}
```

LIMPIAR COOKIE (NUESTRA):
```
export async function clearSessionCookie() {
  cookieStore.delete(COOKIE_NAME);
}
```

---

7. DASHBOARD PRINCIPAL (/dashboard)
===================================

Archivo: src/app/dashboard/page.tsx

VERIFICACI√ìN DE ACCESO:
```
const session = await auth()
if (!session?.user?.id) {
  redirect('/login')
}
```

QU√â MUESTRA:
- Saludo personalizado: "Bienvenido, [nombre]"
- Bot√≥n "Cerrar Sesi√≥n" (form con server action)
- Lista de viajes del usuario
- Bot√≥n "Crear Viaje"

QUERY DE DATOS (PRISMA):
```
const userTravels = await prisma.userTravel.findMany({
  where: { userId: session.user.id },
  include: {
    travel: {
      include: {
        _count: { 
          select: { expenses: true, userTravels: true } 
        }
      }
    }
  },
  orderBy: { travel: { createdAt: 'desc' } }
})
```

DIFERENCIACI√ìN VISUAL:
- Viajes activos (isActive: true): fondo blanco, texto normal
- Viajes finalizados (isActive: false): fondo gris, opacidad reducida

INFORMACI√ìN POR VIAJE:
- T√≠tulo y descripci√≥n
- Fecha de creaci√≥n
- N√∫mero de participantes activos
- N√∫mero de gastos
- Rol del usuario (admin/member)
- Estado (Activo/Finalizado)

---

8. P√ÅGINA DE VIAJE INDIVIDUAL (/travel/[travelId])
==================================================

Archivo: src/app/travel/[travelId]/page.tsx

VERIFICACIONES DE ACCESO:
1. Usuario autenticado: await auth()
2. Usuario pertenece al viaje: prisma.userTravel.findFirst()
3. Viaje existe: prisma.travel.findUnique()

QUERY COMPLEJA DE DATOS:
```
const travel = await prisma.travel.findUnique({
  where: { id: travelId },
  include: {
    userTravels: {
      where: { leftAt: null }, // Solo participantes activos
      include: { user: { select: { id, firstName, lastName, email } } }
    },
    expenses: {
      include: {
        payer: { select: { id, firstName, lastName, email } },
        participants: {
          include: { user: { select: { id, firstName, lastName, email } } }
        }
      },
      orderBy: { createdAt: 'desc' }
    }
  }
});
```

TRES PESTA√ëAS PRINCIPALES:

PESTA√ëA GASTOS (?tab=expenses):
- Formulario "Agregar Nuevo Gasto" (AddExpenseForm)
- Lista de gastos existentes (ExpenseList)
- Resumen de balances (BalanceSummary)

PESTA√ëA LIQUIDACI√ìN (?tab=settlement):
- C√°lculos de deudas individuales
- Sugerencias de pagos √≥ptimos
- Bot√≥n "Viaje Liquidado" (solo admins)
- Estado de liquidaci√≥n

PESTA√ëA PARTICIPANTES (?tab=participants):
- Lista de participantes activos
- Agregar nuevos participantes (solo admins)
- Remover participantes sin historial (solo admins)

C√ÅLCULO DE LIQUIDACI√ìN:
```
const settlement = calculateTravelSettlement(expenseData, userData);
```

---

9. SISTEMA DE LIQUIDACI√ìN INTELIGENTE
=====================================

Archivo: src/lib/settlement.ts

FUNCI√ìN PRINCIPAL (NUESTRA):
```
export function calculateTravelSettlement(expenses, users) {
  const balances = calculateBalances(expenses, users);
  const settlements = calculateSettlements(balances);
  
  return {
    balances,           // Balance individual de cada usuario
    settlements,        // Transferencias sugeridas
    totalExpenses,      // Total gastado en el viaje
    isSettled          // Si todas las deudas est√°n saldadas
  };
}
```

ALGORITMO DE BALANCES:
```
function calculateBalances(expenses, users) {
  expenses.forEach(expense => {
    // Sumar lo que pag√≥ cada usuario
    if (expense.payerId === userId) balance += expense.amount;
    
    // Restar lo que debe cada participante
    const participation = expense.participants.find(p => p.userId === userId);
    if (participation) balance -= participation.share;
  });
}
```

ALGORITMO DE LIQUIDACI√ìN:
- Separa usuarios con balance positivo (les deben) y negativo (deben)
- Calcula transferencias m√≠nimas para saldar todas las deudas
- Optimiza el n√∫mero de transacciones necesarias

EJEMPLO DE RESULTADO:
```
balances: [
  { userId: "user1", balance: 150000 },  // Le deben 150k
  { userId: "user2", balance: -75000 },  // Debe 75k
  { userId: "user3", balance: -75000 }   // Debe 75k
]

settlements: [
  { from: "user2", to: "user1", amount: 75000 },
  { from: "user3", to: "user1", amount: 75000 }
]
```

---

10. GESTI√ìN DE PARTICIPANTES
============================

AGREGAR PARTICIPANTES:
- Solo administradores pueden agregar
- Busca usuario por email en la base de datos
- Crea registro en UserTravel con rol 'member'
- Validaci√≥n: usuario no puede estar ya en el viaje

REMOVER PARTICIPANTES:
- Solo administradores pueden remover
- RESTRICCI√ìN: Solo se pueden remover usuarios SIN historial de gastos
- Validaci√≥n: hasExpenseHistory() verifica si particip√≥ en alg√∫n gasto
- Si tiene historial ‚Üí se muestra mensaje de error
- Si no tiene historial ‚Üí se puede remover sin problemas

L√ìGICA DE VALIDACI√ìN:
```
function hasExpenseHistory(participantId, expenses) {
  return expenses.some(expense =>
    expense.payerId === participantId ||
    expense.participants.some(p => p.userId === participantId)
  );
}
```

---

11. LOGOUT
==========

Archivo: src/app/login/_actions/logout.ts

SERVER ACTION (NUESTRA):
```
export async function logoutAction(_formData: FormData) {
  await clearSessionCookie(); // Borra la cookie fb_session
}
```

FLUJO COMPLETO:
1. Usuario hace clic en bot√≥n "Cerrar Sesi√≥n" (form button)
2. Se ejecuta logoutAction como server action
3. clearSessionCookie() borra la cookie del navegador
4. En la pr√≥xima navegaci√≥n, middleware detecta ausencia de cookie
5. Middleware redirige autom√°ticamente a /login
6. Usuario debe autenticarse nuevamente

IMPLEMENTACI√ìN EN DASHBOARD:
```
<form action={logoutAction}>
  <button type="submit">Cerrar Sesi√≥n</button>
</form>
```

---

12. ESTRUCTURA DE BASE DE DATOS
===============================

MODELO USER:
- id: Identificador √∫nico (CUID)
- email: Email √∫nico del usuario
- firebaseUid: UID de Firebase (√∫nico)
- firstName, lastName: Nombres del usuario
- phone: Tel√©fono opcional
- Relaciones: userTravels[], paidExpenses[], expenseParticipations[]

MODELO TRAVEL:
- id: Identificador √∫nico
- title: T√≠tulo del viaje
- description: Descripci√≥n opcional
- isActive: Si el viaje est√° activo o finalizado
- Relaciones: userTravels[], expenses[]

MODELO USERTRAVEL (Tabla de uni√≥n):
- userId, travelId: Claves for√°neas
- role: 'admin' o 'member'
- joinedAt: Fecha de ingreso
- leftAt: Fecha de salida (null si est√° activo)
- exitBalance: Balance al momento de salir

MODELO EXPENSE:
- id: Identificador √∫nico
- travelId: Viaje al que pertenece
- payerId: Usuario que pag√≥
- title: T√≠tulo del gasto
- amount: Monto total
- category: Categor√≠a opcional
- Relaciones: travel, payer, participants[]

MODELO EXPENSEPARTICIPANT:
- expenseId, userId: Claves for√°neas
- share: Monto que debe pagar este participante
- Restricci√≥n: √önica combinaci√≥n por gasto

---

===============================================================================
                            DIAGRAMAS DE FLUJO
===============================================================================

FLUJO PRINCIPAL DE USUARIO:
```
Usuario ‚Üí Landing (/) ‚Üí ¬øTiene sesi√≥n? 
                           ‚Üì No
                    Login/Register ‚Üí Firebase Auth ‚Üí Server Action 
                           ‚Üì
                    Cookie de sesi√≥n ‚Üí Dashboard ‚Üí Lista de viajes
                           ‚Üì
                    Seleccionar viaje ‚Üí Verificar acceso ‚Üí P√°gina de viaje
                           ‚Üì
                    Pesta√±as: Gastos/Liquidaci√≥n/Participantes
                           ‚Üì
                    Interacciones ‚Üí Server Actions ‚Üí Base de datos
```

FLUJO DE AUTENTICACI√ìN:
```
Formulario ‚Üí Firebase Client ‚Üí ID Token ‚Üí Server Action ‚Üí Firebase Admin
                                              ‚Üì
                                        Verificar token ‚Üí PostgreSQL
                                              ‚Üì
                                        Cookie de sesi√≥n ‚Üí Redirecci√≥n
```

FLUJO DE MIDDLEWARE:
```
Request ‚Üí ¬øRuta protegida? ‚Üí ¬øTiene cookie? ‚Üí ¬øCookie v√°lida?
             ‚Üì S√≠              ‚Üì No            ‚Üì No
         Continuar         Redirect login   Redirect login
```

FLUJO DE LIQUIDACI√ìN:
```
Gastos ‚Üí Calcular balances ‚Üí Algoritmo de optimizaci√≥n ‚Üí Sugerencias de pago
           ‚Üì
    Balance individual ‚Üí ¬øEst√° liquidado? ‚Üí Bot√≥n finalizar viaje
```

===============================================================================
                                RESUMEN T√âCNICO
===============================================================================

FUNCIONES NUESTRAS:
- Middleware personalizado con rate limiting y protecci√≥n de rutas
- Server Actions para todas las operaciones CRUD
- Sistema de cookies de sesi√≥n seguras
- Algoritmo de liquidaci√≥n inteligente
- Validaciones de acceso y permisos
- Gesti√≥n de participantes con restricciones
- Interfaz responsiva y optimizada

FUNCIONES EXTERNAS:
- Firebase Authentication (client y admin)
- Prisma ORM para PostgreSQL
- Next.js 14 con App Router
- Tailwind CSS para estilos

SEGURIDAD IMPLEMENTADA:
- Cookies httpOnly, secure, sameSite
- Verificaci√≥n de tokens en cada request
- Rate limiting por IP
- Headers de seguridad (CSP, XSS, etc.)
- Validaci√≥n de permisos en server actions
- Protecci√≥n contra CSRF

CARACTER√çSTICAS AVANZADAS:
- Algoritmo de liquidaci√≥n con optimizaci√≥n de transferencias
- Gesti√≥n colaborativa con roles (admin/member)
- Historial de gastos inmutable
- C√°lculo inteligente de deudas
- Interfaz adaptativa m√≥vil/desktop
- Sistema de notificaciones con toasts

===============================================================================
